"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[14692],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,d=c["".concat(l,".").concat(m)]||c[m]||h[m]||o;return t?a.createElement(d,i(i({ref:n},u),{},{components:t})):a.createElement(d,i({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},45710:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const o={},i="Wikibase Agent",s={unversionedId:"use_cases/more/agents/agents/wikibase_agent",id:"use_cases/more/agents/agents/wikibase_agent",title:"Wikibase Agent",description:"This notebook demonstrates a very simple wikibase agent that uses sparql generation. Although this code is intended to work against any",source:"@site/docs/use_cases/more/agents/agents/wikibase_agent.md",sourceDirName:"use_cases/more/agents/agents",slug:"/use_cases/more/agents/agents/wikibase_agent",permalink:"/langchain/docs/use_cases/more/agents/agents/wikibase_agent",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"use_cases",previous:{title:"SalesGPT - Your Context-Aware AI Sales Assistant With Knowledge Base",permalink:"/langchain/docs/use_cases/more/agents/agents/sales_agent_with_context"},next:{title:"Autonomous (long-running) agents",permalink:"/langchain/docs/use_cases/more/agents/autonomous_agents/"}},l={},p=[{value:"Preliminaries",id:"preliminaries",level:2},{value:"API keys and other secrats",id:"api-keys-and-other-secrats",level:3},{value:"OpenAI API Key",id:"openai-api-key",level:3},{value:"Wikidata user-agent header",id:"wikidata-user-agent-header",level:3},{value:"Enable tracing if desired",id:"enable-tracing-if-desired",level:3},{value:"Item and Property lookup",id:"item-and-property-lookup",level:2},{value:"Sparql runner",id:"sparql-runner",level:2},{value:"Wrap the tools",id:"wrap-the-tools",level:2},{value:"Prompts",id:"prompts",level:2},{value:"Output parser",id:"output-parser",level:2},{value:"Specify the LLM model",id:"specify-the-llm-model",level:2},{value:"Agent and agent executor",id:"agent-and-agent-executor",level:2},{value:"Run it!",id:"run-it",level:2}],u=(c="CodeOutputBlock",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var c;const h={toc:p},m="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"wikibase-agent"},"Wikibase Agent"),(0,r.kt)("p",null,"This notebook demonstrates a very simple wikibase agent that uses sparql generation. Although this code is intended to work against any\nwikibase instance, we use ",(0,r.kt)("a",{parentName:"p",href:"http://wikidata.org"},"http://wikidata.org")," for testing."),(0,r.kt)("p",null,"If you are interested in wikibases and sparql, please consider helping to improve this agent. Look ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/donaldziff/langchain-wikibase"},"here")," for more details and open questions."),(0,r.kt)("h2",{id:"preliminaries"},"Preliminaries"),(0,r.kt)("h3",{id:"api-keys-and-other-secrats"},"API keys and other secrats"),(0,r.kt)("p",null,"We use an ",(0,r.kt)("inlineCode",{parentName:"p"},".ini")," file, like this: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[OPENAI]\nOPENAI_API_KEY=xyzzy\n[WIKIDATA]\nWIKIDATA_USER_AGENT_HEADER=argle-bargle\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import configparser\n\nconfig = configparser.ConfigParser()\nconfig.read("./secrets.ini")\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    ['./secrets.ini']\n"))),(0,r.kt)("h3",{id:"openai-api-key"},"OpenAI API Key"),(0,r.kt)("p",null,"An OpenAI API key is required unless you modify the code below to use another LLM provider."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'openai_api_key = config["OPENAI"]["OPENAI_API_KEY"]\nimport os\n\nos.environ.update({"OPENAI_API_KEY": openai_api_key})\n')),(0,r.kt)("h3",{id:"wikidata-user-agent-header"},"Wikidata user-agent header"),(0,r.kt)("p",null,"Wikidata policy requires a user-agent header. See ",(0,r.kt)("a",{parentName:"p",href:"https://meta.wikimedia.org/wiki/User-Agent_policy"},"https://meta.wikimedia.org/wiki/User-Agent_policy"),". However, at present this policy is not strictly enforced."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'wikidata_user_agent_header = (\n    None\n    if not config.has_section("WIKIDATA")\n    else config["WIKIDATA"]["WIKIDATA_USER_AGENT_HEADER"]\n)\n')),(0,r.kt)("h3",{id:"enable-tracing-if-desired"},"Enable tracing if desired"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# import os\n# os.environ["LANGCHAIN_HANDLER"] = "langchain"\n# os.environ["LANGCHAIN_SESSION"] = "default" # Make sure this session actually exists.\n')),(0,r.kt)("h1",{id:"tools"},"Tools"),(0,r.kt)("p",null,"Three tools are provided for this simple agent:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ItemLookup"),": for finding the q-number of an item"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PropertyLookup"),": for finding the p-number of a property"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SparqlQueryRunner"),": for running a sparql query")),(0,r.kt)("h2",{id:"item-and-property-lookup"},"Item and Property lookup"),(0,r.kt)("p",null,"Item and Property lookup are implemented in a single method, using an elastic search endpoint. Not all wikibase instances have it, but wikidata does, and that's where we'll start."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def get_nested_value(o: dict, path: list) -> any:\n    current = o\n    for key in path:\n        try:\n            current = current[key]\n        except:\n            return None\n    return current\n\n\nimport requests\n\nfrom typing import Optional\n\n\ndef vocab_lookup(\n    search: str,\n    entity_type: str = "item",\n    url: str = "https://www.wikidata.org/w/api.php",\n    user_agent_header: str = wikidata_user_agent_header,\n    srqiprofile: str = None,\n) -> Optional[str]:\n    headers = {"Accept": "application/json"}\n    if wikidata_user_agent_header is not None:\n        headers["User-Agent"] = wikidata_user_agent_header\n\n    if entity_type == "item":\n        srnamespace = 0\n        srqiprofile = "classic_noboostlinks" if srqiprofile is None else srqiprofile\n    elif entity_type == "property":\n        srnamespace = 120\n        srqiprofile = "classic" if srqiprofile is None else srqiprofile\n    else:\n        raise ValueError("entity_type must be either \'property\' or \'item\'")\n\n    params = {\n        "action": "query",\n        "list": "search",\n        "srsearch": search,\n        "srnamespace": srnamespace,\n        "srlimit": 1,\n        "srqiprofile": srqiprofile,\n        "srwhat": "text",\n        "format": "json",\n    }\n\n    response = requests.get(url, headers=headers, params=params)\n\n    if response.status_code == 200:\n        title = get_nested_value(response.json(), ["query", "search", 0, "title"])\n        if title is None:\n            return f"I couldn\'t find any {entity_type} for \'{search}\'. Please rephrase your request and try again"\n        # if there is a prefix, strip it off\n        return title.split(":")[-1]\n    else:\n        return "Sorry, I got an error. Please try again."\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'print(vocab_lookup("Malin 1"))\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    Q4180017\n"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'print(vocab_lookup("instance of", entity_type="property"))\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    P31\n"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'print(vocab_lookup("Ceci n\'est pas un q-item"))\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    I couldn't find any item for 'Ceci n'est pas un q-item'. Please rephrase your request and try again\n"))),(0,r.kt)("h2",{id:"sparql-runner"},"Sparql runner"),(0,r.kt)("p",null,"This tool runs sparql - by default, wikidata is used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import requests\nfrom typing import List, Dict, Any\nimport json\n\n\ndef run_sparql(\n    query: str,\n    url="https://query.wikidata.org/sparql",\n    user_agent_header: str = wikidata_user_agent_header,\n) -> List[Dict[str, Any]]:\n    headers = {"Accept": "application/json"}\n    if wikidata_user_agent_header is not None:\n        headers["User-Agent"] = wikidata_user_agent_header\n\n    response = requests.get(\n        url, headers=headers, params={"query": query, "format": "json"}\n    )\n\n    if response.status_code != 200:\n        return "That query failed. Perhaps you could try a different one?"\n    results = get_nested_value(response.json(), ["results", "bindings"])\n    return json.dumps(results)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'run_sparql("SELECT (COUNT(?children) as ?count) WHERE { wd:Q1339 wdt:P40 ?children . }")\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    \'[{"count": {"datatype": "http://www.w3.org/2001/XMLSchema#integer", "type": "literal", "value": "20"}}]\'\n'))),(0,r.kt)("h1",{id:"agent"},"Agent"),(0,r.kt)("h2",{id:"wrap-the-tools"},"Wrap the tools"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "Tool", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/tools/langchain.tools.base.Tool.html", "title": "Wikibase Agent"}, {"imported": "AgentExecutor", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/agents/langchain.agents.agent.AgentExecutor.html", "title": "Wikibase Agent"}, {"imported": "LLMSingleActionAgent", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/agents/langchain.agents.agent.LLMSingleActionAgent.html", "title": "Wikibase Agent"}, {"imported": "AgentOutputParser", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/agents/langchain.agents.agent.AgentOutputParser.html", "title": "Wikibase Agent"}, {"imported": "StringPromptTemplate", "source": "langchain.prompts", "docs": "https://api.python.langchain.com/en/latest/prompts/langchain.prompts.base.StringPromptTemplate.html", "title": "Wikibase Agent"}, {"imported": "AgentAction", "source": "langchain.schema", "docs": "https://api.python.langchain.com/en/latest/schema/langchain.schema.agent.AgentAction.html", "title": "Wikibase Agent"}, {"imported": "AgentFinish", "source": "langchain.schema", "docs": "https://api.python.langchain.com/en/latest/schema/langchain.schema.agent.AgentFinish.html", "title": "Wikibase Agent"}]--\x3e\nfrom langchain.agents import (\n    Tool,\n    AgentExecutor,\n    LLMSingleActionAgent,\n    AgentOutputParser,\n)\nfrom langchain.prompts import StringPromptTemplate\nfrom langchain import OpenAI, LLMChain\nfrom typing import List, Union\nfrom langchain.schema import AgentAction, AgentFinish\nimport re\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Define which tools the agent can use to answer user queries\ntools = [\n    Tool(\n        name="ItemLookup",\n        func=(lambda x: vocab_lookup(x, entity_type="item")),\n        description="useful for when you need to know the q-number for an item",\n    ),\n    Tool(\n        name="PropertyLookup",\n        func=(lambda x: vocab_lookup(x, entity_type="property")),\n        description="useful for when you need to know the p-number for a property",\n    ),\n    Tool(\n        name="SparqlQueryRunner",\n        func=run_sparql,\n        description="useful for getting results from a wikibase",\n    ),\n]\n')),(0,r.kt)("h2",{id:"prompts"},"Prompts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Set up the base template\ntemplate = """\nAnswer the following questions by running a sparql query against a wikibase where the p and q items are \ncompletely unknown to you. You will need to discover the p and q items before you can generate the sparql.\nDo not assume you know the p and q items for any concepts. Always use tools to find all p and q items.\nAfter you generate the sparql, you should run it. The results will be returned in json. \nSummarize the json results in natural language.\n\nYou may assume the following prefixes:\nPREFIX wd: <http://www.wikidata.org/entity/>\nPREFIX wdt: <http://www.wikidata.org/prop/direct/>\nPREFIX p: <http://www.wikidata.org/prop/>\nPREFIX ps: <http://www.wikidata.org/prop/statement/>\n\nWhen generating sparql:\n* Try to avoid "count" and "filter" queries if possible\n* Never enclose the sparql in back-quotes\n\nYou have access to the following tools:\n\n{tools}\n\nUse the following format:\n\nQuestion: the input question for which you must provide a natural language answer\nThought: you should always think about what to do\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n... (this Thought/Action/Action Input/Observation can repeat N times)\nThought: I now know the final answer\nFinal Answer: the final answer to the original input question\n\nQuestion: {input}\n{agent_scratchpad}"""\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Set up a prompt template\nclass CustomPromptTemplate(StringPromptTemplate):\n    # The template to use\n    template: str\n    # The list of tools available\n    tools: List[Tool]\n\n    def format(self, **kwargs) -> str:\n        # Get the intermediate steps (AgentAction, Observation tuples)\n        # Format them in a particular way\n        intermediate_steps = kwargs.pop("intermediate_steps")\n        thoughts = ""\n        for action, observation in intermediate_steps:\n            thoughts += action.log\n            thoughts += f"\\nObservation: {observation}\\nThought: "\n        # Set the agent_scratchpad variable to that value\n        kwargs["agent_scratchpad"] = thoughts\n        # Create a tools variable from the list of tools provided\n        kwargs["tools"] = "\\n".join(\n            [f"{tool.name}: {tool.description}" for tool in self.tools]\n        )\n        # Create a list of tool names for the tools provided\n        kwargs["tool_names"] = ", ".join([tool.name for tool in self.tools])\n        return self.template.format(**kwargs)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'prompt = CustomPromptTemplate(\n    template=template,\n    tools=tools,\n    # This omits the `agent_scratchpad`, `tools`, and `tool_names` variables because those are generated dynamically\n    # This includes the `intermediate_steps` variable because that is needed\n    input_variables=["input", "intermediate_steps"],\n)\n')),(0,r.kt)("h2",{id:"output-parser"},"Output parser"),(0,r.kt)("p",null,"This is unchanged from langchain docs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class CustomOutputParser(AgentOutputParser):\n    def parse(self, llm_output: str) -> Union[AgentAction, AgentFinish]:\n        # Check if agent should finish\n        if "Final Answer:" in llm_output:\n            return AgentFinish(\n                # Return values is generally always a dictionary with a single `output` key\n                # It is not recommended to try anything else at the moment :)\n                return_values={"output": llm_output.split("Final Answer:")[-1].strip()},\n                log=llm_output,\n            )\n        # Parse out the action and action input\n        regex = r"Action: (.*?)[\\n]*Action Input:[\\s]*(.*)"\n        match = re.search(regex, llm_output, re.DOTALL)\n        if not match:\n            raise ValueError(f"Could not parse LLM output: `{llm_output}`")\n        action = match.group(1).strip()\n        action_input = match.group(2)\n        # Return the action and action input\n        return AgentAction(\n            tool=action, tool_input=action_input.strip(" ").strip(\'"\'), log=llm_output\n        )\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"output_parser = CustomOutputParser()\n")),(0,r.kt)("h2",{id:"specify-the-llm-model"},"Specify the LLM model"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "ChatOpenAI", "source": "langchain.chat_models", "docs": "https://api.python.langchain.com/en/latest/chat_models/langchain.chat_models.openai.ChatOpenAI.html", "title": "Wikibase Agent"}]--\x3e\nfrom langchain.chat_models import ChatOpenAI\n\nllm = ChatOpenAI(model_name="gpt-4", temperature=0)\n')),(0,r.kt)("h2",{id:"agent-and-agent-executor"},"Agent and agent executor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# LLM chain consisting of the LLM and a prompt\nllm_chain = LLMChain(llm=llm, prompt=prompt)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'tool_names = [tool.name for tool in tools]\nagent = LLMSingleActionAgent(\n    llm_chain=llm_chain,\n    output_parser=output_parser,\n    stop=["\\nObservation:"],\n    allowed_tools=tool_names,\n)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"agent_executor = AgentExecutor.from_agent_and_tools(\n    agent=agent, tools=tools, verbose=True\n)\n")),(0,r.kt)("h2",{id:"run-it"},"Run it!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# If you prefer in-line tracing, uncomment this line\n# agent_executor.agent.llm_chain.verbose = True\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'agent_executor.run("How many children did J.S. Bach have?")\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    \n    \n    > Entering new AgentExecutor chain...\n    Thought: I need to find the Q number for J.S. Bach.\n    Action: ItemLookup\n    Action Input: J.S. Bach\n    \n    Observation:Q1339I need to find the P number for children.\n    Action: PropertyLookup\n    Action Input: children\n    \n    Observation:P1971Now I can query the number of children J.S. Bach had.\n    Action: SparqlQueryRunner\n    Action Input: SELECT ?children WHERE { wd:Q1339 wdt:P1971 ?children }\n    \n    Observation:[{"children": {"datatype": "http://www.w3.org/2001/XMLSchema#decimal", "type": "literal", "value": "20"}}]I now know the final answer.\n    Final Answer: J.S. Bach had 20 children.\n    \n    > Finished chain.\n\n\n\n\n\n    \'J.S. Bach had 20 children.\'\n'))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'agent_executor.run(\n    "What is the Basketball-Reference.com NBA player ID of Hakeem Olajuwon?"\n)\n')),(0,r.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    \n    \n    > Entering new AgentExecutor chain...\n    Thought: To find Hakeem Olajuwon\'s Basketball-Reference.com NBA player ID, I need to first find his Wikidata item (Q-number) and then query for the relevant property (P-number).\n    Action: ItemLookup\n    Action Input: Hakeem Olajuwon\n    \n    Observation:Q273256Now that I have Hakeem Olajuwon\'s Wikidata item (Q273256), I need to find the P-number for the Basketball-Reference.com NBA player ID property.\n    Action: PropertyLookup\n    Action Input: Basketball-Reference.com NBA player ID\n    \n    Observation:P2685Now that I have both the Q-number for Hakeem Olajuwon (Q273256) and the P-number for the Basketball-Reference.com NBA player ID property (P2685), I can run a SPARQL query to get the ID value.\n    Action: SparqlQueryRunner\n    Action Input: \n    SELECT ?playerID WHERE {\n      wd:Q273256 wdt:P2685 ?playerID .\n    }\n    \n    Observation:[{"playerID": {"type": "literal", "value": "o/olajuha01"}}]I now know the final answer\n    Final Answer: Hakeem Olajuwon\'s Basketball-Reference.com NBA player ID is "o/olajuha01".\n    \n    > Finished chain.\n\n\n\n\n\n    \'Hakeem Olajuwon\\\'s Basketball-Reference.com NBA player ID is "o/olajuha01".\'\n'))))}d.isMDXComponent=!0}}]);