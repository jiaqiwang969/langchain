"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[22985],{3905:(n,e,t)=>{t.d(e,{Zo:()=>p,kt:()=>g});var a=t(67294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,a,i=function(n,e){if(null==n)return{};var t,a,i={},o=Object.keys(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var s=a.createContext({}),c=function(n){var e=a.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},p=function(n){var e=c(n.components);return a.createElement(s.Provider,{value:e},n.children)},d="mdxType",u={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,o=n.originalType,s=n.parentName,p=l(n,["components","mdxType","originalType","parentName"]),d=c(t),m=i,g=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return t?a.createElement(g,r(r({ref:e},p),{},{components:t})):a.createElement(g,r({ref:e},p))}));function g(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=n,l[d]="string"==typeof n?n:i,r[1]=l;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},94701:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(87462),i=(t(67294),t(3905));const o={},r="Pydantic compatibility",l={unversionedId:"guides/pydantic_compatibility",id:"guides/pydantic_compatibility",title:"Pydantic compatibility",description:"- Pydantic v2 was released in June, 2023 (https://docs.pydantic.dev/2.0/blog/pydantic-v2-final/)",source:"@site/docs/guides/pydantic_compatibility.md",sourceDirName:"guides",slug:"/guides/pydantic_compatibility",permalink:"/langchain/docs/guides/pydantic_compatibility",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Reversible data anonymization with Microsoft Presidio",permalink:"/langchain/docs/guides/privacy/presidio_reversible_anonymization"},next:{title:"Moderation",permalink:"/langchain/docs/guides/safety/"}},s={},c=[{value:"LangChain Pydantic migration plan",id:"langchain-pydantic-migration-plan",level:2}],p={toc:c},d="wrapper";function u(n){let{components:e,...t}=n;return(0,i.kt)(d,(0,a.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"pydantic-compatibility"},"Pydantic compatibility"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pydantic v2 was released in June, 2023 (",(0,i.kt)("a",{parentName:"li",href:"https://docs.pydantic.dev/2.0/blog/pydantic-v2-final/"},"https://docs.pydantic.dev/2.0/blog/pydantic-v2-final/"),")"),(0,i.kt)("li",{parentName:"ul"},"v2 contains has a number of breaking changes (",(0,i.kt)("a",{parentName:"li",href:"https://docs.pydantic.dev/2.0/migration/"},"https://docs.pydantic.dev/2.0/migration/"),")"),(0,i.kt)("li",{parentName:"ul"},"Pydantic v2 and v1 are under the same package name, so both versions cannot be installed at the same time")),(0,i.kt)("h2",{id:"langchain-pydantic-migration-plan"},"LangChain Pydantic migration plan"),(0,i.kt)("p",null,"As of ",(0,i.kt)("inlineCode",{parentName:"p"},"langchain>=0.0.267"),", LangChain will allow users to install either Pydantic V1 or V2. "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Internally LangChain will continue to ",(0,i.kt)("a",{parentName:"li",href:"https://docs.pydantic.dev/latest/migration/#continue-using-pydantic-v1-features"},"use V1"),"."),(0,i.kt)("li",{parentName:"ul"},"During this time, users can pin their pydantic version to v1 to avoid breaking changes, or start a partial\nmigration using pydantic v2 throughout their code, but avoiding mixing v1 and v2 code for LangChain (see below).")),(0,i.kt)("p",null,"User can either pin to pydantic v1, and upgrade their code in one go once LangChain has migrated to v2 internally, or they can start a partial migration to v2, but must avoid mixing v1 and v2 code for LangChain."),(0,i.kt)("p",null,"Below are two examples of showing how to avoid mixing pydantic v1 and v2 code in\nthe case of inheritance and in the case of passing objects to LangChain."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1: Extending via inheritance")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"YES")," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pydantic.v1 import root_validator, validator\n\nclass CustomTool(BaseTool): # BaseTool is v1 code\n    x: int = Field(default=1)\n\n    def _run(*args, **kwargs):\n        return \"hello\"\n\n    @validator('x') # v1 code\n    @classmethod\n    def validate_x(cls, x: int) -> int:\n        return 1\n    \n\nCustomTool(\n    name='custom_tool',\n    description=\"hello\",\n    x=1,\n)\n")),(0,i.kt)("p",null,"Mixing Pydantic v2 primitives with Pydantic v1 primitives can raise cryptic errors"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NO")," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pydantic import Field, field_validator # pydantic v2\n\nclass CustomTool(BaseTool): # BaseTool is v1 code\n    x: int = Field(default=1)\n\n    def _run(*args, **kwargs):\n        return \"hello\"\n\n    @field_validator('x') # v2 code\n    @classmethod\n    def validate_x(cls, x: int) -> int:\n        return 1\n    \n\nCustomTool( \n    name='custom_tool',\n    description=\"hello\",\n    x=1,\n)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2: Passing objects to LangChain")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"YES")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from langchain.tools.base import Tool\nfrom pydantic.v1 import BaseModel, Field # <-- Uses v1 namespace\n\nclass CalculatorInput(BaseModel):\n    question: str = Field()\n\nTool.from_function( # <-- tool uses v1 namespace\n    func=lambda question: \'hello\',\n    name="Calculator",\n    description="useful for when you need to answer questions about math",\n    args_schema=CalculatorInput\n)\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NO")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from langchain.tools.base import Tool\nfrom pydantic import BaseModel, Field # <-- Uses v2 namespace\n\nclass CalculatorInput(BaseModel):\n    question: str = Field()\n\nTool.from_function( # <-- tool uses v1 namespace\n    func=lambda question: \'hello\',\n    name="Calculator",\n    description="useful for when you need to answer questions about math",\n    args_schema=CalculatorInput\n)\n')))}u.isMDXComponent=!0}}]);