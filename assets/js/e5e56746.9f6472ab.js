"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[42992],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=r.createContext({}),l=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(i.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=l(n),d=o,f=u["".concat(i,".").concat(d)]||u[d]||m[d]||a;return n?r.createElement(f,s(s({ref:t},c),{},{components:n})):r.createElement(f,s({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=d;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[u]="string"==typeof e?e:o,s[1]=p;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},60246:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>u,default:()=>g,frontMatter:()=>c,metadata:()=>m,toc:()=>f});var r=n(87462),o=(n(67294),n(3905));const a=(s="CodeOutputBlock",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var s;const p={toc:[]},i="wrapper";function l(e){let{components:t,...n}=e;return(0,o.kt)(i,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"For this example, we'll use the above Pydantic output parser. Here's what happens if we pass it a result that does not comply with the schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate\nfrom langchain.llms import OpenAI\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.output_parsers import PydanticOutputParser\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'class Actor(BaseModel):\n    name: str = Field(description="name of an actor")\n    film_names: List[str] = Field(description="list of names of films they starred in")\n        \nactor_query = "Generate the filmography for a random actor."\n\nparser = PydanticOutputParser(pydantic_object=Actor)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"misformatted = \"{'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}\"\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"parser.parse(misformatted)\n")),(0,o.kt)(a,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    ---------------------------------------------------------------------------\n\n    JSONDecodeError                           Traceback (most recent call last)\n\n    File ~/workplace/langchain/langchain/output_parsers/pydantic.py:23, in PydanticOutputParser.parse(self, text)\n         22     json_str = match.group()\n    ---\x3e 23 json_object = json.loads(json_str)\n         24 return self.pydantic_object.parse_obj(json_object)\n\n\n    File ~/.pyenv/versions/3.9.1/lib/python3.9/json/__init__.py:346, in loads(s, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)\n        343 if (cls is None and object_hook is None and\n        344         parse_int is None and parse_float is None and\n        345         parse_constant is None and object_pairs_hook is None and not kw):\n    --\x3e 346     return _default_decoder.decode(s)\n        347 if cls is None:\n\n\n    File ~/.pyenv/versions/3.9.1/lib/python3.9/json/decoder.py:337, in JSONDecoder.decode(self, s, _w)\n        333 \"\"\"Return the Python representation of ``s`` (a ``str`` instance\n        334 containing a JSON document).\n        335 \n        336 \"\"\"\n    --\x3e 337 obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n        338 end = _w(s, end).end()\n\n\n    File ~/.pyenv/versions/3.9.1/lib/python3.9/json/decoder.py:353, in JSONDecoder.raw_decode(self, s, idx)\n        352 try:\n    --\x3e 353     obj, end = self.scan_once(s, idx)\n        354 except StopIteration as err:\n\n\n    JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n\n    \n    During handling of the above exception, another exception occurred:\n\n\n    OutputParserException                     Traceback (most recent call last)\n\n    Cell In[6], line 1\n    ----\x3e 1 parser.parse(misformatted)\n\n\n    File ~/workplace/langchain/langchain/output_parsers/pydantic.py:29, in PydanticOutputParser.parse(self, text)\n         27 name = self.pydantic_object.__name__\n         28 msg = f\"Failed to parse {name} from completion {text}. Got: {e}\"\n    ---\x3e 29 raise OutputParserException(msg)\n\n\n    OutputParserException: Failed to parse Actor from completion {'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}. Got: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n"))),(0,o.kt)("p",null,"Now we can construct and use a ",(0,o.kt)("inlineCode",{parentName:"p"},"OutputFixingParser"),". This output parser takes as an argument another output parser but also an LLM with which to try to correct any formatting mistakes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from langchain.output_parsers import OutputFixingParser\n\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"new_parser.parse(misformatted)\n")),(0,o.kt)(a,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    Actor(name='Tom Hanks', film_names=['Forrest Gump'])\n"))))}l.isMDXComponent=!0;const c={},u="Auto-fixing parser",m={unversionedId:"modules/model_io/output_parsers/output_fixing_parser",id:"modules/model_io/output_parsers/output_fixing_parser",title:"Auto-fixing parser",description:"This output parser wraps another output parser, and in the event that the first one fails it calls out to another LLM to fix any errors.",source:"@site/docs/modules/model_io/output_parsers/output_fixing_parser.mdx",sourceDirName:"modules/model_io/output_parsers",slug:"/modules/model_io/output_parsers/output_fixing_parser",permalink:"/langchain/docs/modules/model_io/output_parsers/output_fixing_parser",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Enum parser",permalink:"/langchain/docs/modules/model_io/output_parsers/enum"},next:{title:"Pydantic (JSON) parser",permalink:"/langchain/docs/modules/model_io/output_parsers/pydantic"}},d={},f=[],h={toc:f},y="wrapper";function g(e){let{components:t,...n}=e;return(0,o.kt)(y,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"auto-fixing-parser"},"Auto-fixing parser"),(0,o.kt)("p",null,"This output parser wraps another output parser, and in the event that the first one fails it calls out to another LLM to fix any errors."),(0,o.kt)("p",null,"But we can do other things besides throw errors. Specifically, we can pass the misformatted output, along with the formatted instructions, to the model and ask it to fix it."),(0,o.kt)(l,{mdxType:"Example"}))}g.isMDXComponent=!0}}]);