"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[29032],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=a,m=c["".concat(l,".").concat(h)]||c[h]||p[h]||r;return n?o.createElement(m,i(i({ref:t},u),{},{components:n})):o.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},19389:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var o=n(87462),a=(n(67294),n(3905));const r={},i="Loading documents from a YouTube url",s={unversionedId:"integrations/document_loaders/youtube_audio",id:"integrations/document_loaders/youtube_audio",title:"Loading documents from a YouTube url",description:"Building chat or QA applications on YouTube videos is a topic of high interest.",source:"@site/docs/integrations/document_loaders/youtube_audio.md",sourceDirName:"integrations/document_loaders",slug:"/integrations/document_loaders/youtube_audio",permalink:"/langchain/docs/integrations/document_loaders/youtube_audio",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"integrations",previous:{title:"Xorbits Pandas DataFrame",permalink:"/langchain/docs/integrations/document_loaders/xorbits"},next:{title:"YouTube transcripts",permalink:"/langchain/docs/integrations/document_loaders/youtube_transcript"}},l={},d=[{value:"YouTube url to text",id:"youtube-url-to-text",level:3},{value:"Building a chat app from YouTube video",id:"building-a-chat-app-from-youtube-video",level:3}],u=(c="CodeOutputBlock",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)});var c;const p={toc:d},h="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"loading-documents-from-a-youtube-url"},"Loading documents from a YouTube url"),(0,a.kt)("p",null,"Building chat or QA applications on YouTube videos is a topic of high interest."),(0,a.kt)("p",null,"Below we show how to easily go from a YouTube url to text to chat!"),(0,a.kt)("p",null,"We wil use the ",(0,a.kt)("inlineCode",{parentName:"p"},"OpenAIWhisperParser"),", which will use the OpenAI Whisper API to transcribe audio to text,\nand the  ",(0,a.kt)("inlineCode",{parentName:"p"},"OpenAIWhisperParserLocal")," for local support and running on private clouds or on premise."),(0,a.kt)("p",null,"Note: You will need to have an ",(0,a.kt)("inlineCode",{parentName:"p"},"OPENAI_API_KEY")," supplied."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "GenericLoader", "source": "langchain.document_loaders.generic", "docs": "https://api.python.langchain.com/en/latest/document_loaders/langchain.document_loaders.generic.GenericLoader.html", "title": "Loading documents from a YouTube url"}, {"imported": "OpenAIWhisperParser", "source": "langchain.document_loaders.parsers", "docs": "https://api.python.langchain.com/en/latest/document_loaders/langchain.document_loaders.parsers.audio.OpenAIWhisperParser.html", "title": "Loading documents from a YouTube url"}, {"imported": "YoutubeAudioLoader", "source": "langchain.document_loaders.blob_loaders.youtube_audio", "docs": "https://api.python.langchain.com/en/latest/document_loaders/langchain.document_loaders.blob_loaders.youtube_audio.YoutubeAudioLoader.html", "title": "Loading documents from a YouTube url"}]--\x3e\nfrom langchain.document_loaders.generic import GenericLoader\nfrom langchain.document_loaders.parsers import OpenAIWhisperParser, OpenAIWhisperParserLocal\nfrom langchain.document_loaders.blob_loaders.youtube_audio import YoutubeAudioLoader\n')),(0,a.kt)("p",null,"We will use ",(0,a.kt)("inlineCode",{parentName:"p"},"yt_dlp")," to download audio for YouTube urls."),(0,a.kt)("p",null,"We will use ",(0,a.kt)("inlineCode",{parentName:"p"},"pydub")," to split downloaded audio files (such that we adhere to Whisper API's 25MB file size limit)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"pip install yt_dlp\n pip install pydub\n pip install librosa\n")),(0,a.kt)("h3",{id:"youtube-url-to-text"},"YouTube url to text"),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"YoutubeAudioLoader")," to fetch / download the audio files."),(0,a.kt)("p",null,"Then, ues ",(0,a.kt)("inlineCode",{parentName:"p"},"OpenAIWhisperParser()")," to transcribe them to text."),(0,a.kt)("p",null,"Let's take the first lecture of Andrej Karpathy's YouTube course as an example! "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# set a flag to switch between local and remote parsing\n# change this to True if you want to use local parsing\nlocal = False\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Two Karpathy lecture videos\nurls = ["https://youtu.be/kCc8FmEb1nY", "https://youtu.be/VMj-3S1tku0"]\n\n# Directory to save audio files\nsave_dir = "~/Downloads/YouTube"\n\n# Transcribe the videos to text\nif local:\n    loader = GenericLoader(YoutubeAudioLoader(urls, save_dir), OpenAIWhisperParserLocal())\nelse:\n    loader = GenericLoader(YoutubeAudioLoader(urls, save_dir), OpenAIWhisperParser())\ndocs = loader.load()\n')),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    [youtube] Extracting URL: https://youtu.be/kCc8FmEb1nY\n    [youtube] kCc8FmEb1nY: Downloading webpage\n    [youtube] kCc8FmEb1nY: Downloading android player API JSON\n    [info] kCc8FmEb1nY: Downloading 1 format(s): 140\n    [dashsegments] Total fragments: 11\n    [download] Destination: /Users/31treehaus/Desktop/AI/langchain-fork/docs/modules/indexes/document_loaders/examples/Let's build GPT\uff1a from scratch, in code, spelled out..m4a\n    [download] 100% of  107.73MiB in 00:00:18 at 5.92MiB/s                   \n    [FixupM4a] Correcting container of \"/Users/31treehaus/Desktop/AI/langchain-fork/docs/modules/indexes/document_loaders/examples/Let's build GPT\uff1a from scratch, in code, spelled out..m4a\"\n    [ExtractAudio] Not converting audio /Users/31treehaus/Desktop/AI/langchain-fork/docs/modules/indexes/document_loaders/examples/Let's build GPT\uff1a from scratch, in code, spelled out..m4a; file is already in target format m4a\n    [youtube] Extracting URL: https://youtu.be/VMj-3S1tku0\n    [youtube] VMj-3S1tku0: Downloading webpage\n    [youtube] VMj-3S1tku0: Downloading android player API JSON\n    [info] VMj-3S1tku0: Downloading 1 format(s): 140\n    [download] /Users/31treehaus/Desktop/AI/langchain-fork/docs/modules/indexes/document_loaders/examples/The spelled-out intro to neural networks and backpropagation\uff1a building micrograd.m4a has already been downloaded\n    [download] 100% of  134.98MiB\n    [ExtractAudio] Not converting audio /Users/31treehaus/Desktop/AI/langchain-fork/docs/modules/indexes/document_loaders/examples/The spelled-out intro to neural networks and backpropagation\uff1a building micrograd.m4a; file is already in target format m4a\n"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# Returns a list of Documents, which can be easily viewed or parsed\ndocs[0].page_content[0:500]\n")),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    \"Hello, my name is Andrej and I've been training deep neural networks for a bit more than a decade. And in this lecture I'd like to show you what neural network training looks like under the hood. So in particular we are going to start with a blank Jupyter notebook and by the end of this lecture we will define and train a neural net and you'll get to see everything that goes on under the hood and exactly sort of how that works on an intuitive level. Now specifically what I would like to do is I w\"\n"))),(0,a.kt)("h3",{id:"building-a-chat-app-from-youtube-video"},"Building a chat app from YouTube video"),(0,a.kt)("p",null,"Given ",(0,a.kt)("inlineCode",{parentName:"p"},"Documents"),", we can easily enable chat / question+answering."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "RetrievalQA", "source": "langchain.chains", "docs": "https://api.python.langchain.com/en/latest/chains/langchain.chains.retrieval_qa.base.RetrievalQA.html", "title": "Loading documents from a YouTube url"}, {"imported": "FAISS", "source": "langchain.vectorstores", "docs": "https://api.python.langchain.com/en/latest/vectorstores/langchain.vectorstores.faiss.FAISS.html", "title": "Loading documents from a YouTube url"}, {"imported": "ChatOpenAI", "source": "langchain.chat_models", "docs": "https://api.python.langchain.com/en/latest/chat_models/langchain.chat_models.openai.ChatOpenAI.html", "title": "Loading documents from a YouTube url"}, {"imported": "OpenAIEmbeddings", "source": "langchain.embeddings", "docs": "https://api.python.langchain.com/en/latest/embeddings/langchain.embeddings.openai.OpenAIEmbeddings.html", "title": "Loading documents from a YouTube url"}, {"imported": "RecursiveCharacterTextSplitter", "source": "langchain.text_splitter", "docs": "https://api.python.langchain.com/en/latest/text_splitter/langchain.text_splitter.RecursiveCharacterTextSplitter.html", "title": "Loading documents from a YouTube url"}]--\x3e\nfrom langchain.chains import RetrievalQA\nfrom langchain.vectorstores import FAISS\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Combine doc\ncombined_docs = [doc.page_content for doc in docs]\ntext = " ".join(combined_docs)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# Split them\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1500, chunk_overlap=150)\nsplits = text_splitter.split_text(text)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# Build an index\nembeddings = OpenAIEmbeddings()\nvectordb = FAISS.from_texts(splits, embeddings)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Build a QA chain\nqa_chain = RetrievalQA.from_chain_type(\n    llm=ChatOpenAI(model_name="gpt-3.5-turbo", temperature=0),\n    chain_type="stuff",\n    retriever=vectordb.as_retriever(),\n)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Ask a question!\nquery = "Why do we need to zero out the gradient before backprop at each step?"\nqa_chain.run(query)\n')),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'    "We need to zero out the gradient before backprop at each step because the backward pass accumulates gradients in the grad attribute of each parameter. If we don\'t reset the grad to zero before each backward pass, the gradients will accumulate and add up, leading to incorrect updates and slower convergence. By resetting the grad to zero before each backward pass, we ensure that the gradients are calculated correctly and that the optimization process works as intended."\n'))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'query = "What is the difference between an encoder and decoder?"\nqa_chain.run(query)\n')),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    'In the context of transformers, an encoder is a component that reads in a sequence of input tokens and generates a sequence of hidden representations. On the other hand, a decoder is a component that takes in a sequence of hidden representations and generates a sequence of output tokens. The main difference between the two is that the encoder is used to encode the input sequence into a fixed-length representation, while the decoder is used to decode the fixed-length representation into an output sequence. In machine translation, for example, the encoder reads in the source language sentence and generates a fixed-length representation, which is then used by the decoder to generate the target language sentence.'\n"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'query = "For any token, what are x, k, v, and q?"\nqa_chain.run(query)\n')),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    'For any token, x is the input vector that contains the private information of that token, k and q are the key and query vectors respectively, which are produced by forwarding linear modules on x, and v is the vector that is calculated by propagating the same linear module on x again. The key vector represents what the token contains, and the query vector represents what the token is looking for. The vector v is the information that the token will communicate to other tokens if it finds them interesting, and it gets aggregated for the purposes of the self-attention mechanism.'\n"))))}m.isMDXComponent=!0}}]);