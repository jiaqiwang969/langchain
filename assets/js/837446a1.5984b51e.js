"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[62355],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,g=u["".concat(s,".").concat(m)]||u[m]||h[m]||o;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},42254:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));const o={},i="Running Agent as an Iterator",l={unversionedId:"modules/agents/how_to/agent_iter",id:"modules/agents/how_to/agent_iter",title:"Running Agent as an Iterator",description:"To demonstrate the AgentExecutorIterator functionality, we will set up a problem where an Agent must:",source:"@site/docs/modules/agents/how_to/agent_iter.md",sourceDirName:"modules/agents/how_to",slug:"/modules/agents/how_to/agent_iter",permalink:"/langchain/docs/modules/agents/how_to/agent_iter",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Add Memory to OpenAI Functions Agent",permalink:"/langchain/docs/modules/agents/how_to/add_memory_openai_functions"},next:{title:"Combine agents and vector stores",permalink:"/langchain/docs/modules/agents/how_to/agent_vectorstore"}},s={},c=[],p=(u="CodeOutputBlock",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var u;const h={toc:c},m="wrapper";function g(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"running-agent-as-an-iterator"},"Running Agent as an Iterator"),(0,r.kt)("p",null,"To demonstrate the ",(0,r.kt)("inlineCode",{parentName:"p"},"AgentExecutorIterator")," functionality, we will set up a problem where an Agent must:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Retrieve three prime numbers from a Tool"),(0,r.kt)("li",{parentName:"ul"},"Multiply these together. ")),(0,r.kt)("p",null,"In this simple problem we can demonstrate adding some logic to verify intermediate steps by checking whether their outputs are prime."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "AgentExecutor", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/agents/langchain.agents.agent.AgentExecutor.html", "title": "Running Agent as an Iterator"}, {"imported": "initialize_agent", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/agents/langchain.agents.initialize.initialize_agent.html", "title": "Running Agent as an Iterator"}, {"imported": "AgentType", "source": "langchain.agents", "docs": "https://api.python.langchain.com/en/latest/agents/langchain.agents.agent_types.AgentType.html", "title": "Running Agent as an Iterator"}, {"imported": "AgentFinish", "source": "langchain.schema", "docs": "https://api.python.langchain.com/en/latest/schema/langchain.schema.agent.AgentFinish.html", "title": "Running Agent as an Iterator"}, {"imported": "Tool", "source": "langchain.agents.tools", "docs": "https://api.python.langchain.com/en/latest/tools/langchain.tools.base.Tool.html", "title": "Running Agent as an Iterator"}, {"imported": "ChatOpenAI", "source": "langchain.chat_models", "docs": "https://api.python.langchain.com/en/latest/chat_models/langchain.chat_models.openai.ChatOpenAI.html", "title": "Running Agent as an Iterator"}]--\x3e\nimport os\n\nimport dotenv\nimport pydantic\nfrom langchain.agents import AgentExecutor, initialize_agent, AgentType\nfrom langchain.schema import AgentFinish\nfrom langchain.agents.tools import Tool\nfrom langchain import LLMMathChain\nfrom langchain.chat_models import ChatOpenAI\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Uncomment if you have a .env in root of repo contains OPENAI_API_KEY\n# dotenv.load_dotenv("../../../../../.env")\n\n# need to use GPT-4 here as GPT-3.5 does not understand, however hard you insist, that\n# it should use the calculator to perform the final calculation\nllm = ChatOpenAI(temperature=0, model="gpt-4")\nllm_math_chain = LLMMathChain.from_llm(llm=llm, verbose=True)\n')),(0,r.kt)("p",null,"Define tools which provide:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"n"),"th prime number (using a small subset for this example) "),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"LLMMathChain")," to act as a calculator")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'primes = {998: 7901, 999: 7907, 1000: 7919}\n\n\nclass CalculatorInput(pydantic.BaseModel):\n    question: str = pydantic.Field()\n\n\nclass PrimeInput(pydantic.BaseModel):\n    n: int = pydantic.Field()\n\n\ndef is_prime(n: int) -> bool:\n    if n <= 1 or (n % 2 == 0 and n > 2):\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef get_prime(n: int, primes: dict = primes) -> str:\n    return str(primes.get(int(n)))\n\n\nasync def aget_prime(n: int, primes: dict = primes) -> str:\n    return str(primes.get(int(n)))\n\n\ntools = [\n    Tool(\n        name="GetPrime",\n        func=get_prime,\n        description="A tool that returns the `n`th prime number",\n        args_schema=PrimeInput,\n        coroutine=aget_prime,\n    ),\n    Tool.from_function(\n        func=llm_math_chain.run,\n        name="Calculator",\n        description="Useful for when you need to compute mathematical expressions",\n        args_schema=CalculatorInput,\n        coroutine=llm_math_chain.arun,\n    ),\n]\n')),(0,r.kt)("p",null,"Construct the agent. We will use the default agent type here."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"agent = initialize_agent(\n    tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True\n)\n")),(0,r.kt)("p",null,"Run the iteration and perform a custom check on certain steps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'question = "What is the product of the 998th, 999th and 1000th prime numbers?"\n\nfor step in agent.iter(question):\n    if output := step.get("intermediate_step"):\n        action, value = output[0]\n        if action.tool == "GetPrime":\n            print(f"Checking whether {value} is prime...")\n            assert is_prime(int(value))\n        # Ask user if they want to continue\n        _continue = input("Should the agent continue (Y/n)?:\\n")\n        if _continue != "Y":\n            break\n')),(0,r.kt)(p,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    \n    \n    > Entering new  chain...\n    I need to find the 998th, 999th and 1000th prime numbers first.\n    Action: GetPrime\n    Action Input: 998\n    Observation: 7901\n    Thought:Checking whether 7901 is prime...\n    Should the agent continue (Y/n)?:\n    Y\n    I have the 998th prime number. Now I need to find the 999th prime number.\n    Action: GetPrime\n    Action Input: 999\n    Observation: 7907\n    Thought:Checking whether 7907 is prime...\n    Should the agent continue (Y/n)?:\n    Y\n    I have the 999th prime number. Now I need to find the 1000th prime number.\n    Action: GetPrime\n    Action Input: 1000\n    Observation: 7919\n    Thought:Checking whether 7919 is prime...\n    Should the agent continue (Y/n)?:\n    Y\n    I have all three prime numbers. Now I need to calculate the product of these numbers.\n    Action: Calculator\n    Action Input: 7901 * 7907 * 7919\n    \n    > Entering new  chain...\n    7901 * 7907 * 7919```text\n    7901 * 7907 * 7919\n    ```\n    ...numexpr.evaluate("7901 * 7907 * 7919")...\n    \n    Answer: 494725326233\n    > Finished chain.\n    \n    Observation: Answer: 494725326233\n    Thought:Should the agent continue (Y/n)?:\n    Y\n    I now know the final answer\n    Final Answer: 494725326233\n    \n    > Finished chain.\n'))))}g.isMDXComponent=!0}}]);