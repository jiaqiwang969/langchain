"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[18358],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),h=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=h(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=h(n),d=a,g=c["".concat(s,".").concat(d)]||c[d]||p[d]||o;return n?r.createElement(g,i(i({ref:t},u),{},{components:n})):r.createElement(g,i({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var h=2;h<o;h++)i[h]=n[h];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},64753:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var r=n(87462),a=(n(67294),n(3905));const o={},i="Tree of Thought (ToT) example",l={unversionedId:"use_cases/more/graph/tot",id:"use_cases/more/graph/tot",title:"Tree of Thought (ToT) example",description:'The Tree of Thought (ToT) is a chain that allows you to query a Large Language Model (LLM) using the Tree of Thought technique. This is based on the paper "Large Language Model Guided Tree-of-Thought"',source:"@site/docs/use_cases/more/graph/tot.md",sourceDirName:"use_cases/more/graph",slug:"/use_cases/more/graph/tot",permalink:"/langchain/docs/use_cases/more/graph/tot",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"use_cases",previous:{title:"Neptune Open Cypher QA Chain",permalink:"/langchain/docs/use_cases/more/graph/neptune_cypher_qa"},next:{title:"Self-checking",permalink:"/langchain/docs/use_cases/more/self_check/"}},s={},h=[{value:"Rules Based Checker",id:"rules-based-checker",level:2},{value:"Tree of Thought Chain",id:"tree-of-thought-chain",level:2}],u=(c="CodeOutputBlock",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)});var c;const p={toc:h},d="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"tree-of-thought-tot-example"},"Tree of Thought (ToT) example"),(0,a.kt)("p",null,"The Tree of Thought (ToT) is a chain that allows you to query a Large Language Model (LLM) using the Tree of Thought technique. This is based on the paper ",(0,a.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/2305.08291.pdf"},'"Large Language Model Guided Tree-of-Thought"')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from langchain.llms import OpenAI\n\nllm = OpenAI(temperature=1, max_tokens=512, model="text-davinci-003")\n')),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    /Users/harrisonchase/.pyenv/versions/3.9.1/envs/langchain/lib/python3.9/site-packages/deeplake/util/check_latest_version.py:32: UserWarning: A newer version of deeplake (3.6.13) is available. It's recommended that you update to the latest version using `pip install -U deeplake`.\n      warnings.warn(\n"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'sudoku_puzzle =   "3,*,*,2|1,*,3,*|*,1,*,3|4,*,*,1"\nsudoku_solution = "3,4,1,2|1,2,3,4|2,1,4,3|4,3,2,1"\nproblem_description = f"""\n{sudoku_puzzle}\n\n- This is a 4x4 Sudoku puzzle.\n- The * represents a cell to be filled.\n- The | character separates rows.\n- At each step, replace one or more * with digits 1-4.\n- There must be no duplicate digits in any row, column or 2x2 subgrid.\n- Keep the known digits from previous valid thoughts in place.\n- Each thought can be a partial or the final solution.\n""".strip()\nprint(problem_description)\n')),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    3,*,*,2|1,*,3,*|*,1,*,3|4,*,*,1\n    \n    - This is a 4x4 Sudoku puzzle.\n    - The * represents a cell to be filled.\n    - The | character separates rows.\n    - At each step, replace one or more * with digits 1-4.\n    - There must be no duplicate digits in any row, column or 2x2 subgrid.\n    - Keep the known digits from previous valid thoughts in place.\n    - Each thought can be a partial or the final solution.\n"))),(0,a.kt)("h2",{id:"rules-based-checker"},"Rules Based Checker"),(0,a.kt)("p",null,"Each thought is evaluated by the thought checker and is given a validity type: valid, invalid or partial. A simple checker can be rule based. For example, in the case of a sudoku puzzle, the checker can check if the puzzle is valid, invalid or partial."),(0,a.kt)("p",null,"In the following code we implement a simple rule based checker for a specific 4x4 sudoku puzzle."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from typing import Tuple\nfrom langchain_experimental.tot.checker import ToTChecker\nfrom langchain_experimental.tot.thought import ThoughtValidity\nimport re\n\nclass MyChecker(ToTChecker):\n    def evaluate(self, problem_description: str, thoughts: Tuple[str, ...] = ()) -> ThoughtValidity:\n        last_thought = thoughts[-1]\n        clean_solution = last_thought.replace(" ", "").replace(\'"\', "")\n        regex_solution = clean_solution.replace("*", ".").replace("|", "\\\\|")\n        if sudoku_solution in clean_solution:\n            return ThoughtValidity.VALID_FINAL\n        elif re.search(regex_solution, sudoku_solution):\n            return ThoughtValidity.VALID_INTERMEDIATE\n        else:\n            return ThoughtValidity.INVALID\n')),(0,a.kt)("p",null,"Just testing the MyChecker class above:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'checker = MyChecker()\nassert checker.evaluate("", ("3,*,*,2|1,*,3,*|*,1,*,3|4,*,*,1",)) == ThoughtValidity.VALID_INTERMEDIATE\nassert checker.evaluate("", ("3,4,1,2|1,2,3,4|2,1,4,3|4,3,2,1",)) == ThoughtValidity.VALID_FINAL\nassert checker.evaluate("", ("3,4,1,2|1,2,3,4|2,1,4,3|4,3,*,1",)) == ThoughtValidity.VALID_INTERMEDIATE\nassert checker.evaluate("", ("3,4,1,2|1,2,3,4|2,1,4,3|4,*,3,1",)) == ThoughtValidity.INVALID\n')),(0,a.kt)("h2",{id:"tree-of-thought-chain"},"Tree of Thought Chain"),(0,a.kt)("p",null,"Initialize and run the ToT chain, with maximum number of interactions ",(0,a.kt)("inlineCode",{parentName:"p"},"k")," set to ",(0,a.kt)("inlineCode",{parentName:"p"},"30")," and the maximum number child thoughts ",(0,a.kt)("inlineCode",{parentName:"p"},"c")," set to ",(0,a.kt)("inlineCode",{parentName:"p"},"8"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from langchain_experimental.tot.base import ToTChain\n\ntot_chain = ToTChain(llm=llm, checker=MyChecker(), k=30, c=5, verbose=True, verbose_llm=False)\ntot_chain.run(problem_description=problem_description)\n")),(0,a.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    \n    \n    > Entering new ToTChain chain...\n    Starting the ToT solve procedure.\n\n\n    /Users/harrisonchase/workplace/langchain/libs/langchain/langchain/chains/llm.py:275: UserWarning: The predict_and_parse method is deprecated, instead pass an output parser directly to LLMChain.\n      warnings.warn(\n\n\n    Thought: 3*,*,2|1*,3,*|*,1,*,3|4,*,*,1\n    Thought: 3*,1,2|1*,3,*|*,1,*,3|4,*,*,1\n    Thought: 3*,1,2|1*,3,4|*,1,*,3|4,*,*,1\n    Thought: 3*,1,2|1*,3,4|*,1,2,3|4,*,*,1\n    Thought: 3*,1,2|1*,3,4|2,1,*,3|4,*,*,1\n\n\n    Type <enum 'ThoughtValidity'> not serializable\n\n\n    Thought: 3,*,*,2|1,*,3,*|*,1,*,3|4,1,*,*\n    Thought: 3,*,*,2|*,3,2,*|*,1,*,3|4,1,*,*\n    Thought: 3,2,*,2|1,*,3,*|*,1,*,3|4,1,*,*\n    Thought: 3,2,*,2|1,*,3,*|1,1,*,3|4,1,*,*\n    Thought: 3,2,*,2|1,1,3,*|1,1,*,3|4,1,*,*\n    Thought: 3,*,*,2|1,2,3,*|*,1,*,3|4,*,*,1\n        Thought: 3,1,4,2|1,2,3,4|2,1,4,3|4,3,2,1\n        Thought: 3,4,1,2|1,2,3,4|2,1,4,3|4,3,2,1\n    \n    > Finished chain.\n\n\n\n\n\n    '3,4,1,2|1,2,3,4|2,1,4,3|4,3,2,1'\n"))))}g.isMDXComponent=!0}}]);