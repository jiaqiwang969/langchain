"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[17208],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=o,d=h["".concat(i,".").concat(u)]||h[u]||m[u]||r;return n?a.createElement(d,l(l({ref:t},c),{},{components:n})):a.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=u;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[h]="string"==typeof e?e:o,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},95903:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const r={},l="Fallbacks",s={unversionedId:"guides/fallbacks",id:"guides/fallbacks",title:"Fallbacks",description:"When working with language models, you may often encounter issues from the underlying APIs, whether these be rate limiting or downtime. Therefore, as you go to move your LLM applications into production it becomes more and more important to safe guard against these. That's why we've introduced the concept of fallbacks.",source:"@site/docs/guides/fallbacks.md",sourceDirName:"guides",slug:"/guides/fallbacks",permalink:"/langchain/docs/guides/fallbacks",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Comparing Chain Outputs",permalink:"/langchain/docs/guides/evaluation/examples/comparisons"},next:{title:"LangSmith",permalink:"/langchain/docs/guides/langsmith/"}},i={},p=[{value:"Handling LLM API Errors",id:"handling-llm-api-errors",level:2},{value:"Fallbacks for Sequences",id:"fallbacks-for-sequences",level:2},{value:"Handling Long Inputs",id:"handling-long-inputs",level:2},{value:"Fallback to Better Model",id:"fallback-to-better-model",level:2}],c=(h="CodeOutputBlock",function(e){return console.warn("Component "+h+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var h;const m={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"fallbacks"},"Fallbacks"),(0,o.kt)("p",null,"When working with language models, you may often encounter issues from the underlying APIs, whether these be rate limiting or downtime. Therefore, as you go to move your LLM applications into production it becomes more and more important to safe guard against these. That's why we've introduced the concept of fallbacks."),(0,o.kt)("p",null,"Crucially, fallbacks can be applied not only on the LLM level but on the whole runnable level. This is important because often times different models require different prompts. So if your call to OpenAI fails, you don't just want to send the same prompt to Anthropic - you probably want want to use a different prompt template and send a different version there."),(0,o.kt)("h2",{id:"handling-llm-api-errors"},"Handling LLM API Errors"),(0,o.kt)("p",null,"This is maybe the most common use case for fallbacks. A request to an LLM API can fail for a variety of reasons - the API could be down, you could have hit rate limits, any number of things. Therefore, using fallbacks can help protect against these types of things."),(0,o.kt)("p",null,"IMPORTANT: By default, a lot of the LLM wrappers catch errors and retry. You will most likely want to turn those off when working with fallbacks. Otherwise the first wrapper will keep on retrying and not failing."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "ChatOpenAI", "source": "langchain.chat_models", "docs": "https://api.python.langchain.com/en/latest/chat_models/langchain.chat_models.openai.ChatOpenAI.html", "title": "Fallbacks"}, {"imported": "ChatAnthropic", "source": "langchain.chat_models", "docs": "https://api.python.langchain.com/en/latest/chat_models/langchain.chat_models.anthropic.ChatAnthropic.html", "title": "Fallbacks"}]--\x3e\nfrom langchain.chat_models import ChatOpenAI, ChatAnthropic\n')),(0,o.kt)("p",null,"First, let's mock out what happens if we hit a RateLimitError from OpenAI"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from unittest.mock import patch\nfrom openai.error import RateLimitError\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# Note that we set max_retries = 0 to avoid retrying on RateLimits, etc\nopenai_llm = ChatOpenAI(max_retries=0)\nanthropic_llm = ChatAnthropic()\nllm = openai_llm.with_fallbacks([anthropic_llm])\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# Let\'s use just the OpenAI LLm first, to show that we run into an error\nwith patch(\'openai.ChatCompletion.create\', side_effect=RateLimitError()):\n    try:\n         print(openai_llm.invoke("Why did the chicken cross the road?"))\n    except:\n        print("Hit error")\n')),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    Hit error\n"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# Now let\'s try with fallbacks to Anthropic\nwith patch(\'openai.ChatCompletion.create\', side_effect=RateLimitError()):\n    try:\n         print(llm.invoke("Why did the the chicken cross the road?"))\n    except:\n        print("Hit error")\n')),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    content=' I don\\'t actually know why the chicken crossed the road, but here are some possible humorous answers:\\n\\n- To get to the other side!\\n\\n- It was too chicken to just stand there. \\n\\n- It wanted a change of scenery.\\n\\n- It wanted to show the possum it could be done.\\n\\n- It was on its way to a poultry farmers\\' convention.\\n\\nThe joke plays on the double meaning of \"the other side\" - literally crossing the road to the other side, or the \"other side\" meaning the afterlife. So it\\'s an anti-joke, with a silly or unexpected pun as the answer.' additional_kwargs={} example=False\n"))),(0,o.kt)("p",null,'We can use our "LLM with Fallbacks" as we would a normal LLM.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "ChatPromptTemplate", "source": "langchain.prompts", "docs": "https://api.python.langchain.com/en/latest/prompts/langchain.prompts.chat.ChatPromptTemplate.html", "title": "Fallbacks"}]--\x3e\nfrom langchain.prompts import ChatPromptTemplate\n\nprompt = ChatPromptTemplate.from_messages(\n    [\n        ("system", "You\'re a nice assistant who always includes a compliment in your response"),\n        ("human", "Why did the {animal} cross the road"),\n    ]\n)\nchain = prompt | llm\nwith patch(\'openai.ChatCompletion.create\', side_effect=RateLimitError()):\n    try:\n         print(chain.invoke({"animal": "kangaroo"}))\n    except:\n        print("Hit error")\n')),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    content=" I don\'t actually know why the kangaroo crossed the road, but I can take a guess! Here are some possible reasons:\\n\\n- To get to the other side (the classic joke answer!)\\n\\n- It was trying to find some food or water \\n\\n- It was trying to find a mate during mating season\\n\\n- It was fleeing from a predator or perceived threat\\n\\n- It was disoriented and crossed accidentally \\n\\n- It was following a herd of other kangaroos who were crossing\\n\\n- It wanted a change of scenery or environment \\n\\n- It was trying to reach a new habitat or territory\\n\\nThe real reason is unknown without more context, but hopefully one of those potential explanations does the joke justice! Let me know if you have any other animal jokes I can try to decipher." additional_kwargs={} example=False\n'))),(0,o.kt)("h2",{id:"fallbacks-for-sequences"},"Fallbacks for Sequences"),(0,o.kt)("p",null,"We can also create fallbacks for sequences, that are sequences themselves. Here we do that with two different models: ChatOpenAI and then normal OpenAI (which does not use a chat model). Because OpenAI is NOT a chat model, you likely want a different prompt."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "StrOutputParser", "source": "langchain.schema.output_parser", "docs": "https://api.python.langchain.com/en/latest/schema/langchain.schema.output_parser.StrOutputParser.html", "title": "Fallbacks"}]--\x3e\n# First let\'s create a chain with a ChatModel\n# We add in a string output parser here so the outputs between the two are the same type\nfrom langchain.schema.output_parser import StrOutputParser\n\nchat_prompt = ChatPromptTemplate.from_messages(\n    [\n        ("system", "You\'re a nice assistant who always includes a compliment in your response"),\n        ("human", "Why did the {animal} cross the road"),\n    ]\n)\n# Here we\'re going to use a bad model name to easily create a chain that will error\nchat_model = ChatOpenAI(model_name="gpt-fake")\nbad_chain = chat_prompt | chat_model | StrOutputParser()\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "OpenAI", "source": "langchain.llms", "docs": "https://api.python.langchain.com/en/latest/llms/langchain.llms.openai.OpenAI.html", "title": "Fallbacks"}, {"imported": "PromptTemplate", "source": "langchain.prompts", "docs": "https://api.python.langchain.com/en/latest/prompts/langchain.prompts.prompt.PromptTemplate.html", "title": "Fallbacks"}]--\x3e\n# Now lets create a chain with the normal OpenAI model\nfrom langchain.llms import OpenAI\nfrom langchain.prompts import PromptTemplate\n\nprompt_template = """Instructions: You should always include a compliment in your response.\n\nQuestion: Why did the {animal} cross the road?"""\nprompt = PromptTemplate.from_template(prompt_template)\nllm = OpenAI()\ngood_chain = prompt | llm\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# We can now create a final chain which combines the two\nchain = bad_chain.with_fallbacks([good_chain])\nchain.invoke({"animal": "turtle"})\n')),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    '\\n\\nAnswer: The turtle crossed the road to get to the other side, and I have to say he had some impressive determination.'\n"))),(0,o.kt)("h2",{id:"handling-long-inputs"},"Handling Long Inputs"),(0,o.kt)("p",null,"One of the big limiting factors of LLMs in their context window. Usually you can count and track the length of prompts before sending them to an LLM, but in situations where that is hard/complicated you can fallback to a model with longer context length."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'short_llm = ChatOpenAI()\nlong_llm = ChatOpenAI(model="gpt-3.5-turbo-16k")\nllm = short_llm.with_fallbacks([long_llm])\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'inputs = "What is the next number: " + ", ".join(["one", "two"] * 3000)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"try:\n    print(short_llm.invoke(inputs))\nexcept Exception as e:\n    print(e)\n")),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    This model's maximum context length is 4097 tokens. However, your messages resulted in 12012 tokens. Please reduce the length of the messages.\n"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"try:\n    print(llm.invoke(inputs))\nexcept Exception as e:\n    print(e)\n")),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    content='The next number in the sequence is two.' additional_kwargs={} example=False\n"))),(0,o.kt)("h2",{id:"fallback-to-better-model"},"Fallback to Better Model"),(0,o.kt)("p",null,"Often times we ask models to output format in a specific format (like JSON). Models like GPT-3.5 can do this okay, but sometimes struggle. This naturally points to fallbacks - we can try with GPT-3.5 (faster, cheaper), but then if parsing fails we can use GPT-4."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'\x3c!--IMPORTS:[{"imported": "DatetimeOutputParser", "source": "langchain.output_parsers", "docs": "https://api.python.langchain.com/en/latest/output_parsers/langchain.output_parsers.datetime.DatetimeOutputParser.html", "title": "Fallbacks"}]--\x3e\nfrom langchain.output_parsers import DatetimeOutputParser\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'prompt = ChatPromptTemplate.from_template(\n    "what time was {event} (in %Y-%m-%dT%H:%M:%S.%fZ format - only return this value)"\n)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# In this case we are going to do the fallbacks on the LLM + output parser level\n# Because the error will get raised in the OutputParser\nopenai_35 = ChatOpenAI() | DatetimeOutputParser()\nopenai_4 = ChatOpenAI(model="gpt-4")| DatetimeOutputParser()\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"only_35 = prompt | openai_35 \nfallback_4 = prompt | openai_35.with_fallbacks([openai_4])\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'try:\n    print(only_35.invoke({"event": "the superbowl in 1994"}))\nexcept Exception as e:\n    print(f"Error: {e}")\n')),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    Error: Could not parse datetime string: The Super Bowl in 1994 took place on January 30th at 3:30 PM local time. Converting this to the specified format (%Y-%m-%dT%H:%M:%S.%fZ) results in: 1994-01-30T15:30:00.000Z\n"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'try:\n    print(fallback_4.invoke({"event": "the superbowl in 1994"}))\nexcept Exception as e:\n    print(f"Error: {e}")\n')),(0,o.kt)(c,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    1994-01-30 15:30:00\n"))))}d.isMDXComponent=!0}}]);