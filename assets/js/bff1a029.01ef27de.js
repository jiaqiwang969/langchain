"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[88688],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},66980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={},i="Perform context-aware text splitting",s={unversionedId:"use_cases/question_answering/how_to/document-context-aware-QA",id:"use_cases/question_answering/how_to/document-context-aware-QA",title:"Perform context-aware text splitting",description:"Text splitting for vector storage often uses sentences or other delimiters to keep related text together.",source:"@site/docs/use_cases/question_answering/how_to/document-context-aware-QA.md",sourceDirName:"use_cases/question_answering/how_to",slug:"/use_cases/question_answering/how_to/document-context-aware-QA",permalink:"/langchain/docs/use_cases/question_answering/how_to/document-context-aware-QA",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"use_cases",previous:{title:"Conversational Retrieval Agent",permalink:"/langchain/docs/use_cases/question_answering/how_to/conversational_retrieval_agents"},next:{title:"Retrieve as you generate with FLARE",permalink:"/langchain/docs/use_cases/question_answering/how_to/flare"}},l={},c=[],p=(u="CodeOutputBlock",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var u;const m={toc:c},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"perform-context-aware-text-splitting"},"Perform context-aware text splitting"),(0,r.kt)("p",null,"Text splitting for vector storage often uses sentences or other delimiters ",(0,r.kt)("a",{parentName:"p",href:"https://www.pinecone.io/learn/chunking-strategies/"},"to keep related text together"),". "),(0,r.kt)("p",null,"But many documents (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Markdown")," files) have structure (headers) that can be explicitly used in splitting. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"MarkdownHeaderTextSplitter")," lets a user split ",(0,r.kt)("inlineCode",{parentName:"p"},"Markdown")," files files based on specified headers. "),(0,r.kt)("p",null,"This results in chunks that retain the header(s) that it came from in the metadata."),(0,r.kt)("p",null,"This works nicely w/ ",(0,r.kt)("inlineCode",{parentName:"p"},"SelfQueryRetriever"),"."),(0,r.kt)("p",null,"First, tell the retriever about our splits."),(0,r.kt)("p",null,'Then, query based on the doc structure (e.g., "summarize the doc introduction"). '),(0,r.kt)("p",null,"Chunks only from that section of the Document will be filtered and used in chat / Q+A."),(0,r.kt)("p",null,"Let's test this out on an ",(0,r.kt)("a",{parentName:"p",href:"https://rlancemartin.notion.site/Auto-Evaluation-of-Metadata-Filtering-18502448c85240828f33716740f9574b?pvs=4"},"example Notion page"),"!"),(0,r.kt)("p",null,"First, I download the page to Markdown as explained ",(0,r.kt)("a",{parentName:"p",href:"https://python.langchain.com/docs/ecosystem/integrations/notion"},"here"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Load Notion page as a markdownfile file\nfrom langchain.document_loaders import NotionDirectoryLoader\n\npath = "../Notion_DB/"\nloader = NotionDirectoryLoader(path)\ndocs = loader.load()\nmd_file = docs[0].page_content\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Let\'s create groups based on the section headers in our page\nfrom langchain.text_splitter import MarkdownHeaderTextSplitter\n\nheaders_to_split_on = [\n    ("###", "Section"),\n]\nmarkdown_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=headers_to_split_on)\nmd_header_splits = markdown_splitter.split_text(md_file)\n')),(0,r.kt)("p",null,"Now, perform text splitting on the header grouped documents. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# Define our text splitter\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nchunk_size = 500\nchunk_overlap = 0\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=chunk_size, chunk_overlap=chunk_overlap\n)\nall_splits = text_splitter.split_documents(md_header_splits)\n")),(0,r.kt)("p",null,"This sets us up well do perform metadata filtering based on the document structure."),(0,r.kt)("p",null,"Let's bring this all togther by building a vectorstore first."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"pip install chromadb\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# Build vectorstore and keep the metadata\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.vectorstores import Chroma\n\nvectorstore = Chroma.from_documents(documents=all_splits, embedding=OpenAIEmbeddings())\n")),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"SelfQueryRetriever")," that can filter based upon metadata we defined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Create retriever\nfrom langchain.llms import OpenAI\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\nfrom langchain.chains.query_constructor.base import AttributeInfo\n\n# Define our metadata\nmetadata_field_info = [\n    AttributeInfo(\n        name="Section",\n        description="Part of the document that the text comes from",\n        type="string or list[string]",\n    ),\n]\ndocument_content_description = "Major sections of the document"\n\n# Define self query retriver\nllm = OpenAI(temperature=0)\nretriever = SelfQueryRetriever.from_llm(\n    llm, vectorstore, document_content_description, metadata_field_info, verbose=True\n)\n')),(0,r.kt)("p",null,"We can see that we can query ",(0,r.kt)("em",{parentName:"p"},"only for texts")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Introduction")," of the document!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Test\nretriever.get_relevant_documents("Summarize the Introduction section of the document")\n')),(0,r.kt)(p,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    query='Introduction' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Introduction') limit=None\n\n\n\n\n\n    [Document(page_content='![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled.png)', metadata={'Section': 'Introduction'}),\n     Document(page_content='Q+A systems often use a two-step approach: retrieve relevant text chunks and then synthesize them into an answer. There many ways to approach this. For example, we recently [discussed](https://blog.langchain.dev/auto-evaluation-of-anthropic-100k-context-window/) the Retriever-Less option (at bottom in the below diagram), highlighting the Anthropic 100k context window model. Metadata filtering is an alternative approach that pre-filters chunks based on a user-defined criteria in a VectorDB using', metadata={'Section': 'Introduction'}),\n     Document(page_content='metadata tags prior to semantic search.', metadata={'Section': 'Introduction'})]\n"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Test\nretriever.get_relevant_documents("Summarize the Introduction section of the document")\n')),(0,r.kt)(p,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    query='Introduction' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Introduction') limit=None\n\n\n\n\n\n    [Document(page_content='![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled.png)', metadata={'Section': 'Introduction'}),\n     Document(page_content='Q+A systems often use a two-step approach: retrieve relevant text chunks and then synthesize them into an answer. There many ways to approach this. For example, we recently [discussed](https://blog.langchain.dev/auto-evaluation-of-anthropic-100k-context-window/) the Retriever-Less option (at bottom in the below diagram), highlighting the Anthropic 100k context window model. Metadata filtering is an alternative approach that pre-filters chunks based on a user-defined criteria in a VectorDB using', metadata={'Section': 'Introduction'}),\n     Document(page_content='metadata tags prior to semantic search.', metadata={'Section': 'Introduction'})]\n"))),(0,r.kt)("p",null,"We can also look at other parts of the document."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'retriever.get_relevant_documents("Summarize the Testing section of the document")\n')),(0,r.kt)(p,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    query='Testing' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Testing') limit=None\n\n\n\n\n\n    [Document(page_content='![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled%202.png)', metadata={'Section': 'Testing'}),\n     Document(page_content='`SelfQueryRetriever` works well in [many cases](https://twitter.com/hwchase17/status/1656791488569954304/photo/1). For example, given [this test case](https://twitter.com/hwchase17/status/1656791488569954304?s=20):  \\n![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled%201.png)  \\nThe query can be nicely broken up into semantic query and metadata filter:  \\n```python\\nsemantic query: \"prompt injection\"', metadata={'Section': 'Testing'}),\n     Document(page_content='Below, we can see detailed results from the app:  \\n- Kor extraction is above to perform the transformation between query and metadata format \u2705\\n- Self-querying attempts to filter using the episode ID (`252`) in the query and fails \ud83d\udeab\\n- Baseline returns docs from 3 different episodes (one from `252`), confusing the answer \ud83d\udeab', metadata={'Section': 'Testing'}),\n     Document(page_content='will use in retrieval [here](https://github.com/langchain-ai/auto-evaluator/blob/main/streamlit/kor_retriever_lex.py).', metadata={'Section': 'Testing'})]\n"))),(0,r.kt)("p",null,"Now, we can create chat or Q+A apps that are aware of the explict document structure. "),(0,r.kt)("p",null,"The ability to retain document structure for metadata filtering can be helpful for complicated or longer documents."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from langchain.chains import RetrievalQA\nfrom langchain.chat_models import ChatOpenAI\n\nllm = ChatOpenAI(model_name="gpt-3.5-turbo", temperature=0)\nqa_chain = RetrievalQA.from_chain_type(llm, retriever=retriever)\nqa_chain.run("Summarize the Testing section of the document")\n')),(0,r.kt)(p,{lang:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    query='Testing' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Testing') limit=None\n\n\n\n\n\n    'The Testing section of the document describes the evaluation of the `SelfQueryRetriever` component in comparison to a baseline model. The evaluation was performed on a test case where the query was broken down into a semantic query and a metadata filter. The results showed that the `SelfQueryRetriever` component was able to perform the transformation between query and metadata format, but failed to filter using the episode ID in the query. The baseline model returned documents from three different episodes, which confused the answer. The `SelfQueryRetriever` component was deemed to work well in many cases and will be used in retrieval.'\n"))))}h.isMDXComponent=!0}}]);