"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[35715],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>h});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function p(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var u=n.createContext({}),i=function(e){var t=n.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},l=function(e){var t=i(e.components);return n.createElement(u.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=i(r),d=o,h=m["".concat(u,".").concat(d)]||m[d]||c[d]||a;return r?n.createElement(h,s(s({ref:t},l),{},{components:r})):n.createElement(h,s({ref:t},l))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=d;var p={};for(var u in t)hasOwnProperty.call(t,u)&&(p[u]=t[u]);p.originalType=e,p[m]="string"==typeof e?e:o,s[1]=p;for(var i=2;i<a;i++)s[i]=r[i];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},52709:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>m,default:()=>y,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var n=r(87462),o=(r(67294),r(3905));const a=(s="CodeOutputBlock",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var s;const p={toc:[]},u="wrapper";function i(e){let{components:t,...r}=e;return(0,o.kt)(u,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Below we go over the main type of output parser, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PydanticOutputParser"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate\nfrom langchain.llms import OpenAI\nfrom langchain.chat_models import ChatOpenAI\n\nfrom langchain.output_parsers import PydanticOutputParser\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"model_name = 'text-davinci-003'\ntemperature = 0.0\nmodel = OpenAI(model_name=model_name, temperature=temperature)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# Define your desired data structure.\nclass Joke(BaseModel):\n    setup: str = Field(description="question to set up a joke")\n    punchline: str = Field(description="answer to resolve the joke")\n    \n    # You can add custom validation logic easily with Pydantic.\n    @validator(\'setup\')\n    def question_ends_with_question_mark(cls, field):\n        if field[-1] != \'?\':\n            raise ValueError("Badly formed question!")\n        return field\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# Set up a parser + inject instructions into the prompt template.\nparser = PydanticOutputParser(pydantic_object=Joke)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'prompt = PromptTemplate(\n    template="Answer the user query.\\n{format_instructions}\\n{query}\\n",\n    input_variables=["query"],\n    partial_variables={"format_instructions": parser.get_format_instructions()}\n)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# And a query intended to prompt a language model to populate the data structure.\njoke_query = "Tell me a joke."\n_input = prompt.format_prompt(query=joke_query)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"output = model(_input.to_string())\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"parser.parse(output)\n")),(0,o.kt)(a,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    Joke(setup='Why did the chicken cross the road?', punchline='To get to the other side!')\n"))))}i.isMDXComponent=!0;const l={sidebar_position:2},m="Output parsers",c={unversionedId:"modules/model_io/output_parsers/index",id:"modules/model_io/output_parsers/index",title:"Output parsers",description:"Language models output text. But many times you may want to get more structured information than just text back. This is where output parsers come in.",source:"@site/docs/modules/model_io/output_parsers/index.mdx",sourceDirName:"modules/model_io/output_parsers",slug:"/modules/model_io/output_parsers/",permalink:"/langchain/docs/modules/model_io/output_parsers/",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Streaming",permalink:"/langchain/docs/modules/model_io/models/chat/streaming"},next:{title:"List parser",permalink:"/langchain/docs/modules/model_io/output_parsers/comma_separated"}},d={},h=[{value:"Get started",id:"get-started",level:2}],g={toc:h},f="wrapper";function y(e){let{components:t,...r}=e;return(0,o.kt)(f,(0,n.Z)({},g,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"output-parsers"},"Output parsers"),(0,o.kt)("p",null,"Language models output text. But many times you may want to get more structured information than just text back. This is where output parsers come in."),(0,o.kt)("p",null,"Output parsers are classes that help structure language model responses. There are two main methods an output parser must implement:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'"Get format instructions": A method which returns a string containing instructions for how the output of a language model should be formatted.'),(0,o.kt)("li",{parentName:"ul"},'"Parse": A method which takes in a string (assumed to be the response from a language model) and parses it into some structure.')),(0,o.kt)("p",null,"And then one optional one:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'"Parse with prompt": A method which takes in a string (assumed to be the response from a language model) and a prompt (assumed to the prompt that generated such a response) and parses it into some structure. The prompt is largely provided in the event the OutputParser wants to retry or fix the output in some way, and needs information from the prompt to do so.')),(0,o.kt)("h2",{id:"get-started"},"Get started"),(0,o.kt)(i,{mdxType:"GetStarted"}))}y.isMDXComponent=!0}}]);